<!DOCTYPE HTML>
<html lang="zh-TW" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Pool：性能提升大殺器 - Go 併發編程實戰課</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Go 併發編程實戰課</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="10--pool性能提升大殺器"><a class="header" href="#10--pool性能提升大殺器">10 | Pool：性能提升大殺器</a></h1>
<p>你好，我是鳥窩。</p>
<p>Go 是一個自動垃圾回收的編程語言，採用三色併發標記算法標記對象並回收。和其它沒有自動垃圾回收的編程語言不同，使用 Go 語言創建對象的時候，我們沒有回收 / 釋放的心理負擔，想用就用，想創建就創建。</p>
<p>但是，<strong>如果你想使用 Go 開發一個高性能的應用程序的話，就必須考慮垃圾回收給性能帶來的影響</strong>，畢竟，Go 的自動垃圾回收機制還是有一個 STW（stop-the-world，程序暫停）的時間，而且，大量地創建在堆上的對象，也會影響垃圾回收標記的時間。</p>
<p>所以，一般我們做性能優化的時候，會採用對象池的方式，把不用的對象回收起來，避免被垃圾回收掉，這樣使用的時候就不必在堆上重新創建了。</p>
<p>不止如此，像數據庫連接、TCP 的長連接，這些連接在創建的時候是一個非常耗時的操作。如果每次都創建一個新的連接對象，耗時較長，很可能整個業務的大部分耗時都花在了創建連接上。</p>
<p>所以，如果我們能把這些連接保存下來，避免每次使用的時候都重新創建，不僅可以大大減少業務的耗時，還能提高應用程序的整體性能。</p>
<p>Go 標準庫中提供了一個通用的 Pool 數據結構，也就是 sync.Pool，我們使用它可以創建池化的對象。這節課我會詳細給你介紹一下 sync.Pool 的使用方法、實現原理以及常見的坑，幫助你全方位地掌握標準庫的 Pool。</p>
<p>不過，這個類型也有一些使用起來不太方便的地方，就是<strong>它池化的對象可能會被垃圾回收掉</strong>，這對於數據庫長連接等場景是不合適的。所以在這一講中，我會專門介紹其它的一些 Pool，包括 TCP 連接池、數據庫連接池等等。</p>
<p>除此之外，我還會專門介紹一個池的應用場景： Worker Pool，或者叫做 goroutine pool，這也是常用的一種併發模式，可以使用有限的 goroutine 資源去處理大量的業務數據。</p>
<h1 id="syncpool"><a class="header" href="#syncpool">sync.Pool</a></h1>
<p>首先，我們來學習下標準庫提供的 sync.Pool 數據類型。</p>
<p>sync.Pool 數據類型用來保存一組可獨立訪問的<strong>臨時</strong>對象。請注意這裡加粗的“臨時”這兩個字，它說明了 sync.Pool 這個數據類型的特點，也就是說，它池化的對象會在未來的某個時候被毫無預兆地移除掉。而且，如果沒有別的對象引用這個被移除的對象的話，這個被移除的對象就會被垃圾回收掉。</p>
<p>因為 Pool 可以有效地減少新對象的申請，從而提高程序性能，所以 Go 內部庫也用到了 sync.Pool，比如 fmt 包，它會使用一個動態大小的 buffer 池做輸出緩存，當大量的 goroutine 併發輸出的時候，就會創建比較多的 buffer，並且在不需要的時候回收掉。</p>
<p>有兩個知識點你需要記住：</p>
<ol>
<li>sync.Pool 本身就是線程安全的，多個 goroutine 可以併發地調用它的方法存取對象；</li>
<li>sync.Pool 不可在使用之後再複製使用。</li>
</ol>
<h2 id="syncpool-的使用方法"><a class="header" href="#syncpool-的使用方法">sync.Pool 的使用方法</a></h2>
<p>知道了 sync.Pool 這個數據類型的特點，接下來，我們來學習下它的使用方法。其實，這個數據類型不難，它只提供了三個對外的方法：New、Get 和 Put。</p>
<p><strong>1.New</strong></p>
<p>Pool struct 包含一個 New 字段，這個字段的類型是函數 func() interface{}。當調用 Pool 的 Get 方法從池中獲取元素，沒有更多的空閒元素可返回時，就會調用這個 New 方法來創建新的元素。如果你沒有設置 New 字段，沒有更多的空閒元素可返回時，Get 方法將返回 nil，表明當前沒有可用的元素。</p>
<p>有趣的是，New 是可變的字段。這就意味著，你可以在程序運行的時候改變創建元素的方法。當然，很少有人會這麼做，因為一般我們創建元素的邏輯都是一致的，要創建的也是同一類的元素，所以你在使用 Pool 的時候也沒必要玩一些“花活”，在程序運行時更改 New 的值。</p>
<p><strong>2.Get</strong></p>
<p>如果調用這個方法，就會從 Pool<strong>取走</strong>一個元素，這也就意味著，這個元素會從 Pool 中移除，返回給調用者。不過，除了返回值是正常實例化的元素，Get 方法的返回值還可能會是一個 nil（Pool.New 字段沒有設置，又沒有空閒元素可以返回），所以你在使用的時候，可能需要判斷。</p>
<p><strong>3.Put</strong></p>
<p>這個方法用於將一個元素返還給 Pool，Pool 會把這個元素保存到池中，並且可以複用。但如果 Put 一個 nil 值，Pool 就會忽略這個值。</p>
<p>好了，瞭解了這幾個方法，下面我們看看 sync.Pool 最常用的一個場景：buffer 池（緩衝池）。</p>
<p>因為 byte slice 是經常被創建銷燬的一類對象，使用 buffer 池可以緩存已經創建的 byte slice，比如，著名的靜態網站生成工具 Hugo 中，就包含這樣的實現bufpool，你可以看一下下面這段代碼：</p>
<pre><code>var buffers = sync.Pool{
  New: func() interface{} { 
    return new(bytes.Buffer)
  },
}

func GetBuffer() *bytes.Buffer {
  return buffers.Get().(*bytes.Buffer)
}

func PutBuffer(buf *bytes.Buffer) {
  buf.Reset()
  buffers.Put(buf)
}
</code></pre>
<p>除了 Hugo，這段 buffer 池的代碼非常常用。很可能你在閱讀其它項目的代碼的時候就碰到過，或者是你自己實現 buffer 池的時候也會這麼去實現，但是請你注意了，這段代碼是有問題的，你一定不要將上面的代碼應用到實際的產品中。它可能會有內存洩漏的問題，下面我會重點講這個問題。</p>
<h2 id="實現原理"><a class="header" href="#實現原理">實現原理</a></h2>
<p>瞭解了 sync.Pool 的基本使用方法，下面我們就來重點學習下它的實現。</p>
<p>Go 1.13 之前的 sync.Pool 的實現有 2 大問題：</p>
<p><strong>1. 每次 GC 都會回收創建的對象。</strong></p>
<p>如果緩存元素數量太多，就會導致 STW 耗時變長；緩存元素都被回收後，會導致 Get 命中率下降，Get 方法不得不新創建很多對象。</p>
<p><strong>2. 底層實現使用了 Mutex，對這個鎖併發請求競爭激烈的時候，會導致性能的下降。</strong></p>
<p>在 Go 1.13 中，sync.Pool 做了大量的優化。前幾講中我提到過，提高併發程序性能的優化點是儘量不要使用鎖，如果不得已使用了鎖，就把鎖 Go 的粒度降到最低。<strong>Go 對 Pool 的優化就是避免使用鎖，同時將加鎖的 queue 改成 lock-free 的 queue 的實現，給即將移除的元素再多一次“復活”的機會。</strong></p>
<p>當前，sync.Pool 的數據結構如下圖所示：</p>
<p><img src="./images/ddd64f753c3df55cd0de5cfaa6782407.png" alt="" /></p>
<p>Pool 最重要的兩個字段是 local 和 victim，因為它們兩個主要用來存儲空閒的元素。弄清楚這兩個字段的處理邏輯，你就能完全掌握 sync.Pool 的實現了。下面我們來看看這兩個字段的關係。</p>
<p>每次垃圾回收的時候，Pool 會把 victim 中的對象移除，然後把 local 的數據給 victim，這樣的話，local 就會被清空，而 victim 就像一個垃圾分揀站，裡面的東西可能會被當做垃圾丟棄了，但是裡面有用的東西也可能被撿回來重新使用。</p>
<p>victim 中的元素如果被 Get 取走，那麼這個元素就很幸運，因為它又“活”過來了。但是，如果這個時候 Get 的併發不是很大，元素沒有被 Get 取走，那麼就會被移除掉，因為沒有別人引用它的話，就會被垃圾回收掉。</p>
<p>下面的代碼是垃圾回收時 sync.Pool 的處理邏輯：</p>
<pre><code>func poolCleanup() {
    // 丟棄當前victim, STW所以不用加鎖
    for _, p := range oldPools {
        p.victim = nil
        p.victimSize = 0
    }

    // 將local複製給victim, 並將原local置為nil
    for _, p := range allPools {
        p.victim = p.local
        p.victimSize = p.localSize
        p.local = nil
        p.localSize = 0
    }

    oldPools, allPools = allPools, nil
}
</code></pre>
<p>在這段代碼中，你需要關注一下 local 字段，因為所有當前主要的空閒可用的元素都存放在 local 字段中，請求元素時也是優先從 local 字段中查找可用的元素。local 字段包含一個 poolLocalInternal 字段，並提供 CPU 緩存對齊，從而避免 false sharing。</p>
<p>而 poolLocalInternal 也包含兩個字段：private 和 shared。</p>
<ol>
<li>private，代表一個緩存的元素，而且只能由相應的一個 P 存取。因為一個 P 同時只能執行一個 goroutine，所以不會有併發的問題。</li>
<li>shared，可以由任意的 P 訪問，但是隻有本地的 P 才能 pushHead/popHead，其它 P 可以 popTail，相當於只有一個本地的 P 作為生產者（Producer），多個 P 作為消費者（Consumer），它是使用一個 local-free 的 queue 列表實現的。</li>
</ol>
<h3 id="get-方法"><a class="header" href="#get-方法">Get 方法</a></h3>
<p>我們來看看 Get 方法的具體實現原理。</p>
<pre><code>func (p *Pool) Get() interface{} {
    // 把當前goroutine固定在當前的P上
    l, pid := p.pin()
    x := l.private // 優先從local的private字段取，快速
    l.private = nil
    if x == nil {
        // 從當前的local.shared彈出一個，注意是從head讀取並移除
        x, _ = l.shared.popHead()
        if x == nil { // 如果沒有，則去偷一個
            x = p.getSlow(pid) 
        }
    }
    runtime_procUnpin()
    // 如果沒有獲取到，嘗試使用New函數生成一個新的
    if x == nil &amp;&amp; p.New != nil {
        x = p.New()
    }
    return x
}
</code></pre>
<p>我來給你解釋下這段代碼。首先，從本地的 private 字段中獲取可用元素，因為沒有鎖，獲取元素的過程會非常快，如果沒有獲取到，就嘗試從本地的 shared 獲取一個，如果還沒有，會使用 getSlow 方法去其它的 shared 中“偷”一個。最後，如果沒有獲取到，就嘗試使用 New 函數創建一個新的。</p>
<p>這裡的重點是 getSlow 方法，我們來分析下。看名字也就知道了，它的耗時可能比較長。它首先要遍歷所有的 local，嘗試從它們的 shared 彈出一個元素。如果還沒找到一個，那麼，就開始對 victim 下手了。</p>
<p>在 vintim 中查詢可用元素的邏輯還是一樣的，先從對應的 victim 的 private 查找，如果查不到，就再從其它 victim 的 shared 中查找。</p>
<p>下面的代碼是 getSlow 方法的主要邏輯：</p>
<pre><code>func (p *Pool) getSlow(pid int) interface{} {

    size := atomic.LoadUintptr(&amp;p.localSize)
    locals := p.local                       
    // 從其它proc中嘗試偷取一個元素
    for i := 0; i &lt; int(size); i++ {
        l := indexLocal(locals, (pid+i+1)%int(size))
        if x, _ := l.shared.popTail(); x != nil {
            return x
        }
    }

    // 如果其它proc也沒有可用元素，那麼嘗試從vintim中獲取
    size = atomic.LoadUintptr(&amp;p.victimSize)
    if uintptr(pid) &gt;= size {
        return nil
    }
    locals = p.victim
    l := indexLocal(locals, pid)
    if x := l.private; x != nil { // 同樣的邏輯，先從vintim中的local private獲取
        l.private = nil
        return x
    }
    for i := 0; i &lt; int(size); i++ { // 從vintim其它proc嘗試偷取
        l := indexLocal(locals, (pid+i)%int(size))
        if x, _ := l.shared.popTail(); x != nil {
            return x
        }
    }

    // 如果victim中都沒有，則把這個victim標記為空，以後的查找可以快速跳過了
    atomic.StoreUintptr(&amp;p.victimSize, 0)

    return nil
}
</code></pre>
<p>這裡我沒列出 pin 代碼的實現，你只需要知道，pin 方法會將此 goroutine 固定在當前的 P 上，避免查找元素期間被其它的 P 執行。固定的好處就是查找元素期間直接得到跟這個 P 相關的 local。有一點需要注意的是，pin 方法在執行的時候，如果跟這個 P 相關的 local 還沒有創建，或者運行時 P 的數量被修改了的話，就會新創建 local。</p>
<h3 id="put-方法"><a class="header" href="#put-方法">Put 方法</a></h3>
<p>我們來看看 Put 方法的具體實現原理。</p>
<pre><code>func (p *Pool) Put(x interface{}) {
    if x == nil { // nil值直接丟棄
        return
    }
    l, _ := p.pin()
    if l.private == nil { // 如果本地private沒有值，直接設置這個值即可
        l.private = x
        x = nil
    }
    if x != nil { // 否則加入到本地隊列中
        l.shared.pushHead(x)
    }
    runtime_procUnpin()
}
</code></pre>
<p>Put 的邏輯相對簡單，優先設置本地 private，如果 private 字段已經有值了，那麼就把此元素 push 到本地隊列中。</p>
<h2 id="syncpool-的坑"><a class="header" href="#syncpool-的坑">sync.Pool 的坑</a></h2>
<p>到這裡，我們就掌握了 sync.Pool 的使用方法和實現原理，接下來，我要再和你聊聊容易踩的兩個坑，分別是內存洩漏和內存浪費。</p>
<h3 id="內存洩漏"><a class="header" href="#內存洩漏">內存洩漏</a></h3>
<p>這節課剛開始的時候，我講到，可以使用 sync.Pool 做 buffer 池，但是，如果用剛剛的那種方式做 buffer 池的話，可能會有內存洩漏的風險。為啥這麼說呢？我們來分析一下。</p>
<p>取出來的 bytes.Buffer 在使用的時候，我們可以往這個元素中增加大量的 byte 數據，這會導致底層的 byte slice 的容量可能會變得很大。這個時候，即使 Reset 再放回到池子中，這些 byte slice 的容量不會改變，所佔的空間依然很大。而且，因為 Pool 回收的機制，這些大的 Buffer 可能不被回收，而是會一直佔用很大的空間，這屬於內存洩漏的問題。</p>
<p>即使是 Go 的標準庫，在內存洩漏這個問題上也栽了幾次坑，比如 issue 23199、@dsnet提供了一個簡單的可重現的例子，演示了內存洩漏的問題。再比如 encoding、json 中類似的問題：將容量已經變得很大的 Buffer 再放回 Pool 中，導致內存洩漏。後來在元素放回時，增加了檢查邏輯，改成放回的超過一定大小的 buffer，就直接丟棄掉，不再放到池子中，如下所示：</p>
<p><img src="./images/8cc73b89d6ce0f8ba191e03de4ffc6b6.png" alt="" /></p>
<p>package fmt 中也有這個問題，修改方法是一樣的，超過一定大小的 buffer，就直接丟棄了：</p>
<p><img src="./images/237216060c9dc859577956e2c81e9cc0.png" alt="" /></p>
<p>在使用 sync.Pool 回收 buffer 的時候，**一定要檢查回收的對象的大小。**如果 buffer 太大，就不要回收了，否則就太浪費了。</p>
<h3 id="內存浪費"><a class="header" href="#內存浪費">內存浪費</a></h3>
<p>除了內存洩漏以外，還有一種浪費的情況，就是池子中的 buffer 都比較大，但在實際使用的時候，很多時候只需要一個小的 buffer，這也是一種浪費現象。接下來，我就講解一下這種情況的處理方法。</p>
<p>要做到物盡其用，儘可能不浪費的話，我們可以將 buffer 池分成幾層。首先，小於 512 byte 的元素的 buffer 佔一個池子；其次，小於 1K byte 大小的元素佔一個池子；再次，小於 4K byte 大小的元素佔一個池子。這樣分成幾個池子以後，就可以根據需要，到所需大小的池子中獲取 buffer 了。</p>
<p>在標準庫 net/http/server.go中的代碼中，就提供了 2K 和 4K 兩個 writer 的池子。你可以看看下面這段代碼：</p>
<p><img src="./images/4eeaebd4ab3e5ed856014d7881299285.png" alt="" /></p>
<p>YouTube 開源的知名項目 vitess 中提供了bucketpool的實現，它提供了更加通用的多層 buffer 池。你在使用的時候，只需要指定池子的最大和最小尺寸，vitess 就會自動計算出合適的池子數。而且，當你調用 Get 方法的時候，只需要傳入你要獲取的 buffer 的大小，就可以了。下面這段代碼就描述了這個過程，你可以看看：</p>
<p><img src="./images/fbef6c64a8cfc87cacbaf8b86e737f32.png" alt="" /></p>
<h1 id="第三方庫"><a class="header" href="#第三方庫">第三方庫</a></h1>
<p>除了這種分層的為了節省空間的 buffer 設計外，還有其它的一些第三方的庫也會提供 buffer 池的功能。接下來我帶你熟悉幾個常用的第三方的庫。</p>
<p>1.bytebufferpool</p>
<p>這是 fasthttp 作者 valyala 提供的一個 buffer 池，基本功能和 sync.Pool 相同。它的底層也是使用 sync.Pool 實現的，包括會檢測最大的 buffer，超過最大尺寸的 buffer，就會被丟棄。</p>
<p>valyala 一向很擅長挖掘系統的性能，這個庫也不例外。它提供了校準（calibrate，用來動態調整創建元素的權重）的機制，可以“智能”地調整 Pool 的 defaultSize 和 maxSize。一般來說，我們使用 buffer size 的場景比較固定，所用 buffer 的大小會集中在某個範圍裡。有了校準的特性，bytebufferpool 就能夠偏重於創建這個範圍大小的 buffer，從而節省空間。</p>
<p>2.oxtoacart/bpool</p>
<p>這也是比較常用的 buffer 池，它提供了以下幾種類型的 buffer。</p>
<ol>
<li>bpool.BufferPool： 提供一個固定元素數量的 buffer 池，元素類型是 bytes.Buffer，如果超過這個數量，Put 的時候就丟棄，如果池中的元素都被取光了，會新建一個返回。Put 回去的時候，不會檢測 buffer 的大小。</li>
<li>bpool.BytesPool：提供一個固定元素數量的 byte slice 池，元素類型是 byte slice。Put 回去的時候不檢測 slice 的大小。</li>
<li>bpool.SizedBufferPool： 提供一個固定元素數量的 buffer 池，如果超過這個數量，Put 的時候就丟棄，如果池中的元素都被取光了，會新建一個返回。Put 回去的時候，會檢測 buffer 的大小，超過指定的大小的話，就會創建一個新的滿足條件的 buffer 放回去。</li>
</ol>
<p>bpool 最大的特色就是能夠保持池子中元素的數量，一旦 Put 的數量多於它的閾值，就會自動丟棄，而 sync.Pool 是一個沒有限制的池子，只要 Put 就會收進去。</p>
<p>bpool 是基於 Channel 實現的，不像 sync.Pool 為了提高性能而做了很多優化，所以，在性能上比不過 sync.Pool。不過，它提供了限制 Pool 容量的功能，所以，如果你想控制 Pool 的容量的話，可以考慮這個庫。</p>
<h1 id="連接池"><a class="header" href="#連接池">連接池</a></h1>
<p>Pool 的另一個很常用的一個場景就是保持 TCP 的連接。一個 TCP 的連接創建，需要三次握手等過程，如果是 TLS 的，還會需要更多的步驟，如果加上身份認證等邏輯的話，耗時會更長。所以，為了避免每次通訊的時候都新創建連接，我們一般會建立一個連接的池子，預先把連接創建好，或者是逐步把連接放在池子中，減少連接創建的耗時，從而提高系統的性能。</p>
<p>事實上，我們很少會使用 sync.Pool 去池化連接對象，原因就在於，sync.Pool 會無通知地在某個時候就把連接移除垃圾回收掉了，而我們的場景是需要長久保持這個連接，所以，我們一般會使用其它方法來池化連接，比如接下來我要講到的幾種需要保持長連接的 Pool。</p>
<h2 id="標準庫中的-http-client-池"><a class="header" href="#標準庫中的-http-client-池">標準庫中的 http client 池</a></h2>
<p>標準庫的 http.Client 是一個 http client 的庫，可以用它來訪問 web 服務器。為了提高性能，這個 Client 的實現也是通過池的方法來緩存一定數量的連接，以便後續重用這些連接。</p>
<p>http.Client 實現連接池的代碼是在 Transport 類型中，它使用 idleConn 保存持久化的可重用的長連接：</p>
<p><img src="./images/6ddfc2648d4ddc38acb4a10f682781c5.png" alt="" /></p>
<h2 id="tcp-連接池"><a class="header" href="#tcp-連接池">TCP 連接池</a></h2>
<p>最常用的一個 TCP 連接池是 fatih 開發的fatih/pool，雖然這個項目已經被 fatih 歸檔（Archived），不再維護了，但是因為它相當穩定了，我們可以開箱即用。即使你有一些特殊的需求，也可以 fork 它，然後自己再做修改。</p>
<p>它的使用套路如下：</p>
<pre><code>// 工廠模式，提供創建連接的工廠方法
factory    := func() (net.Conn, error) { return net.Dial("tcp", "127.0.0.1:4000") }

// 創建一個tcp池，提供初始容量和最大容量以及工廠方法
p, err := pool.NewChannelPool(5, 30, factory)

// 獲取一個連接
conn, err := p.Get()

// Close並不會真正關閉這個連接，而是把它放回池子，所以你不必顯式地Put這個對象到池子中
conn.Close()

// 通過調用MarkUnusable, Close的時候就會真正關閉底層的tcp的連接了
if pc, ok := conn.(*pool.PoolConn); ok {
  pc.MarkUnusable()
  pc.Close()
}

// 關閉池子就會關閉=池子中的所有的tcp連接
p.Close()

// 當前池子中的連接的數量
current := p.Len()
</code></pre>
<p>雖然我一直在說 TCP，但是它管理的是更通用的 net.Conn，不侷限於 TCP 連接。</p>
<p>它通過把 net.Conn 包裝成 PoolConn，實現了攔截 net.Conn 的 Close 方法，避免了真正地關閉底層連接，而是把這個連接放回到池中：</p>
<pre><code>    type PoolConn struct {
    net.Conn
    mu       sync.RWMutex
    c        *channelPool
    unusable bool
  }
  
    //攔截Close
  func (p *PoolConn) Close() error {
    p.mu.RLock()
    defer p.mu.RUnlock()
  
    if p.unusable {
      if p.Conn != nil {
        return p.Conn.Close()
      }
      return nil
    }
    return p.c.put(p.Conn)
  }
</code></pre>
<p>它的 Pool 是通過 Channel 實現的，空閒的連接放入到 Channel 中，這也是 Channel 的一個應用場景：</p>
<pre><code>    type channelPool struct {
    // 存儲連接池的channel
    mu    sync.RWMutex
    conns chan net.Conn
  

    // net.Conn 的產生器
    factory Factory
  }數據庫連接池標準庫 sql.DB 還提供了一個通用的數據庫的連接池，通過 MaxOpenConns 和 MaxIdleConns 控制最大的連接數和最大的 idle 的連接數。默認的 MaxIdleConns 是 2，這個數對於數據庫相關的應用來說太小了，我們一般都會調整它。
</code></pre>
<p><img src="./images/f614c3577e5e81b5abcf73a002f1024a.png" alt="" /></p>
<p>DB 的 freeConn 保存了 idle 的連接，這樣，當我們獲取數據庫連接的時候，它就會優先嚐試從 freeConn 獲取已有的連接（conn）。</p>
<p><img src="./images/cf1d61845efbd8a5b0dbbdb22326c057.png" alt="" /></p>
<h2 id="memcached-client-連接池"><a class="header" href="#memcached-client-連接池">Memcached Client 連接池</a></h2>
<p>Brad Fitzpatrick 是知名緩存庫 Memcached 的原作者，前 Go 團隊成員。gomemcache是他使用 Go 開發的 Memchaced 的客戶端，其中也用了連接池的方式池化 Memcached 的連接。接下來讓我們看看它的連接池的實現。</p>
<p>gomemcache Client 有一個 freeconn 的字段，用來保存空閒的連接。當一個請求使用完之後，它會調用 putFreeConn 放回到池子中，請求的時候，調用 getFreeConn 優先查詢 freeConn 中是否有可用的連接。它採用 Mutex+Slice 實現 Pool：</p>
<pre><code>   // 放回一個待重用的連接
   func (c *Client) putFreeConn(addr net.Addr, cn *conn) {
    c.lk.Lock()
    defer c.lk.Unlock()
    if c.freeconn == nil { // 如果對象為空，創建一個map對象
      c.freeconn = make(map[string][]*conn)
    }
    freelist := c.freeconn[addr.String()] //得到此地址的連接列表
    if len(freelist) &gt;= c.maxIdleConns() {//如果連接已滿,關閉，不再放入
      cn.nc.Close()
      return
    }
    c.freeconn[addr.String()] = append(freelist, cn) // 加入到空閒列表中
  }
  
    // 得到一個空閒連接
  func (c *Client) getFreeConn(addr net.Addr) (cn *conn, ok bool) {
    c.lk.Lock()
    defer c.lk.Unlock()
    if c.freeconn == nil { 
      return nil, false
    }
    freelist, ok := c.freeconn[addr.String()]
    if !ok || len(freelist) == 0 { // 沒有此地址的空閒列表，或者列表為空
      return nil, false
    }
    cn = freelist[len(freelist)-1] // 取出尾部的空閒連接
    c.freeconn[addr.String()] = freelist[:len(freelist)-1]
    return cn, true
  }
Worker Pool最後，我再講一個 Pool 應用得非常廣泛的場景。
</code></pre>
<p>你已經知道，goroutine 是一個很輕量級的“纖程”，在一個服務器上可以創建十幾萬甚至幾十萬的 goroutine。但是“可以”和“合適”之間還是有區別的，你會在應用中讓幾十萬的 goroutine 一直跑嗎？基本上是不會的。</p>
<p>一個 goroutine 初始的棧大小是 2048 個字節，並且在需要的時候可以擴展到 1GB（具體的內容你可以課下看看代碼中的配置：不同的架構最大數會不同），所以，大量的 goroutine 還是很耗資源的。同時，大量的 goroutine 對於調度和垃圾回收的耗時還是會有影響的，因此，goroutine 並不是越多越好。</p>
<p>有的時候，我們就會創建一個 Worker Pool 來減少 goroutine 的使用。比如，我們實現一個 TCP 服務器，如果每一個連接都要由一個獨立的 goroutine 去處理的話，在大量連接的情況下，就會創建大量的 goroutine，這個時候，我們就可以創建一個固定數量的 goroutine（Worker），由這一組 Worker 去處理連接，比如 fasthttp 中的Worker Pool。</p>
<p>Worker 的實現也是五花八門的：</p>
<ol>
<li>有些是在後臺默默執行的，不需要等待返回結果；</li>
<li>有些需要等待一批任務執行完；</li>
<li>有些 Worker Pool 的生命週期和程序一樣長；</li>
<li>有些只是臨時使用，執行完畢後，Pool 就銷燬了。</li>
</ol>
<p>大部分的 Worker Pool 都是通過 Channel 來緩存任務的，因為 Channel 能夠比較方便地實現併發的保護，有的是多個 Worker 共享同一個任務 Channel，有些是每個 Worker 都有一個獨立的 Channel。</p>
<p>綜合下來，精挑細選，我給你推薦三款易用的 Worker Pool，這三個 Worker Pool 的 API 設計簡單，也比較相似，易於和項目集成，而且提供的功能也是我們常用的功能。</p>
<ol>
<li>gammazero/workerpool：gammazero/workerpool 可以無限制地提交任務，提供了更便利的 Submit 和 SubmitWait 方法提交任務，還可以提供當前的 worker 數和任務數以及關閉 Pool 的功能。</li>
<li>ivpusic/grpool：grpool 創建 Pool 的時候需要提供 Worker 的數量和等待執行的任務的最大數量，任務的提交是直接往 Channel 放入任務。</li>
<li>dpaks/goworkers：dpaks/goworkers 提供了更便利的 Submi 方法提交任務以及 Worker 數、任務數等查詢方法、關閉 Pool 的方法。它的任務的執行結果需要在 ResultChan 和 ErrChan 中去獲取，沒有提供阻塞的方法，但是它可以在初始化的時候設置 Worker 的數量和任務數。</li>
</ol>
<p>類似的 Worker Pool 的實現非常多，比如還有panjf2000/ants、Jeffail/tunny 、benmanns/goworker、go-playground/pool、Sherifabdlnaby/gpool等第三方庫。pond也是一個非常不錯的 Worker Pool，關注度目前不是很高，但是功能非常齊全。</p>
<p>其實，你也可以自己去開發自己的 Worker Pool，但是，對於我這種“懶惰”的人來說，只要滿足我的實際需求，我還是傾向於從這個幾個常用的庫中選擇一個來使用。所以，我建議你也從常用的庫中進行選擇。</p>
<h1 id="總結"><a class="header" href="#總結">總結</a></h1>
<p>Pool 是一個通用的概念，也是解決對象重用和預先分配的一個常用的優化手段。即使你自己沒在項目中直接使用過，但肯定在使用其它庫的時候，就享受到應用 Pool 的好處了，比如數據庫的訪問、http API 的請求等等。</p>
<p>我們一般不會在程序一開始的時候就開始考慮優化，而是等項目開發到一個階段，或者快結束的時候，才全面地考慮程序中的優化點，而 Pool 就是常用的一個優化手段。如果你發現程序中有一種 GC 耗時特別高，有大量的相同類型的臨時對象，不斷地被創建銷燬，這時，你就可以考慮看看，是不是可以通過池化的手段重用這些對象。</p>
<p>另外，在分佈式系統或者微服務框架中，可能會有大量的併發 Client 請求，如果 Client 的耗時佔比很大，你也可以考慮池化 Client，以便重用。</p>
<p>如果你發現系統中的 goroutine 數量非常多，程序的內存資源佔用比較大，而且整體系統的耗時和 GC 也比較高，我建議你看看，是否能夠通過 Worker Pool 解決大量 goroutine 的問題，從而降低這些指標。</p>
<p><img src="./images/53e14c4cfe534647dca0014ee1bfa5bb.png" alt="" /></p>
<h1 id="思考題"><a class="header" href="#思考題">思考題</a></h1>
<p>在標準庫 net/rpc 包中，Server 端需要解析大量客戶端的請求（Request），這些短暫使用的 Request 是可以重用的。請你檢查相關的代碼，看看 Go 開發者都使用了什麼樣的方式來重用這些對象。</p>
<p>歡迎在留言區寫下你的思考和答案，我們一起交流討論。如果你覺得有所收穫，也歡迎你把今天的內容分享給你的朋友或同事。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="10.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="12.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="10.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="12.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
