<!DOCTYPE HTML>
<html lang="zh-TW" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>Context：信息穿透上下文 - Go 併發編程實戰課</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Go 併發編程實戰課</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="11--context信息穿透上下文"><a class="header" href="#11--context信息穿透上下文">11 | Context：信息穿透上下文</a></h1>
<p>你好，我是鳥窩。</p>
<p>在這節課正式開始之前，我想先帶你看一個工作中的場景。</p>
<p>假設有一天你進入辦公室，突然同事們都圍住你，然後大喊“小王小王你最帥”，此時你可能一頭霧水，只能尷尬地笑笑。為啥呢？因為你缺少上下文的信息，不知道之前發生了什麼。</p>
<p>但是，如果同事告訴你，由於你業績突出，一天之內就把雲服務化的主要架構寫好了，因此被評為 9 月份的工作之星，總經理還特意給你發 1 萬元的獎金，那麼，你心裡就很清楚了，原來同事恭喜你，是因為你的工作被表揚了，還獲得了獎金。同事告訴你的這些前因後果，就是上下文信息，他把上下文傳遞給你，你接收後，就可以獲取之前不瞭解的信息。</p>
<p>你看，上下文（Context）就是這麼重要。在我們的開發場景中，上下文也是不可或缺的，缺少了它，我們就不能獲取完整的程序信息。那到底啥是上下文呢？其實，這就是指，在 API 之間或者方法調用之間，所傳遞的除了業務參數之外的額外信息。</p>
<p>比如，服務端接收到客戶端的 HTTP 請求之後，可以把客戶端的 IP 地址和端口、客戶端的身份信息、請求接收的時間、Trace ID 等信息放入到上下文中，這個上下文可以在後端的方法調用中傳遞，後端的業務方法除了利用正常的參數做一些業務處理（如訂單處理）之外，還可以從上下文讀取到消息請求的時間、Trace ID 等信息，把服務處理的時間推送到 Trace 服務中。Trace 服務可以把同一 Trace ID 的不同方法的調用順序和調用時間展示成流程圖，方便跟蹤。</p>
<p>不過，Go 標準庫中的 Context 功能還不止於此，它還提供了超時（Timeout）和取消（Cancel）的機制，下面就讓我一一道來。</p>
<h1 id="context-的來歷"><a class="header" href="#context-的來歷">Context 的來歷</a></h1>
<p>在學習 Context 的功能之前呢，我先帶你瞭解下它的來歷。畢竟，知道了它的來龍去脈，我們才能應用得更加得心應手一些。</p>
<p>Go 在 1.7 的版本中才正式把 Context 加入到標準庫中。在這之前，很多 Web 框架在定義自己的 handler 時，都會傳遞一個自定義的 Context，把客戶端的信息和客戶端的請求信息放入到 Context 中。Go 最初提供了 golang.org/x/net/context 庫用來提供上下文信息，最終還是在 Go1.7 中把此庫提升到標準庫 context 包中。</p>
<p>為啥呢？這是因為，在 Go1.7 之前，有很多庫都依賴 golang.org/x/net/context 中的 Context 實現，這就導致 Go 1.7 發佈之後，出現了標準庫 Context 和 golang.org/x/net/context 並存的狀況。新的代碼使用標準庫 Context 的時候，沒有辦法使用這個標準庫的 Context 去調用舊有的使用 x/net/context 實現的方法。</p>
<p>所以，在 Go1.9 中，還專門實現了一個叫做 type alias 的新特性，然後把 x/net/context 中的 Context 定義成標準庫 Context 的別名，以解決新舊 Context 類型衝突問題，你可以看一下下面這段代碼：</p>
<pre><code class="language-go">    // +build go1.9
  package context
  
  import "context"
  
  type Context = context.Context
  type CancelFunc = context.CancelFunc
</code></pre>
<p>Go 標準庫的 Context 不僅提供了上下文傳遞的信息，還提供了 cancel、timeout 等其它信息，這些信息貌似和 context 這個包名沒關係，但是還是得到了廣泛的應用。所以，你看，context 包中的 Context 不僅僅傳遞上下文信息，還有 timeout 等其它功能，是不是“名不副實”呢？</p>
<p>其實啊，這也是這個 Context 的一個問題，比較容易誤導人，Go 佈道師 Dave Cheney 還專門寫了一篇文章講述這個問題：Context isn’t for cancellation。</p>
<p>同時，也有一些批評者針對 Context 提出了批評：Context should go away for Go 2，這篇文章把 Context 比作病毒，病毒會傳染，結果把所有的方法都傳染上了病毒（加上 Context 參數），絕對是視覺汙染。</p>
<p>Go 的開發者也注意到了“關於 Context，存在一些爭議”這件事兒，所以，Go 核心開發者 Ian Lance Taylor 專門開了一個issue 28342，用來記錄當前的 Context 的問題：</p>
<ol>
<li>Context 包名導致使用的時候重複 ctx context.Context；</li>
<li>Context.WithValue 可以接受任何類型的值，非類型安全；</li>
<li>Context 包名容易誤導人，實際上，Context 最主要的功能是取消 goroutine 的執行；</li>
<li>Context 漫天飛，函數汙染。</li>
</ol>
<p>儘管有很多的爭議，但是，在很多場景下，使用 Context 其實會很方便，所以現在它已經在 Go 生態圈中傳播開來了，包括很多的 Web 應用框架，都切換成了標準庫的 Context。標準庫中的 database/sql、os/exec、net、net/http 等包中都使用到了 Context。而且，如果我們遇到了下面的一些場景，也可以考慮使用 Context：</p>
<ol>
<li>上下文信息傳遞 （request-scoped），比如處理 http 請求、在請求處理鏈路上傳遞信息；</li>
<li>控制子 goroutine 的運行；</li>
<li>超時控制的方法調用；</li>
<li>可以取消的方法調用。</li>
</ol>
<p>所以，我們需要掌握 Context 的具體用法，這樣才能在不影響主要業務流程實現的時候，實現一些通用的信息傳遞，或者是能夠和其它 goroutine 協同工作，提供 timeout、cancel 等機制。</p>
<h1 id="context-基本使用方法"><a class="header" href="#context-基本使用方法">Context 基本使用方法</a></h1>
<p>首先，我們來學習一下 Context 接口包含哪些方法，這些方法都是幹什麼用的。</p>
<p>包 context 定義了 Context 接口，Context 的具體實現包括 4 個方法，分別是 Deadline、Done、Err 和 Value，如下所示：</p>
<pre><code class="language-go">type Context interface {
    Deadline() (deadline time.Time, ok bool)
    Done() &lt;-chan struct{}
    Err() error
    Value(key interface{}) interface{}
}
</code></pre>
<p>下面我來具體解釋下這 4 個方法。</p>
<p><strong>Deadline</strong> 方法會返回這個 Context 被取消的截止日期。如果沒有設置截止日期，ok 的值是 false。後續每次調用這個對象的 Deadline 方法時，都會返回和第一次調用相同的結果。</p>
<p><strong>Done</strong> 方法返回一個 Channel 對象。在 Context 被取消時，此 Channel 會被 close，如果沒被取消，可能會返回 nil。後續的 Done 調用總是返回相同的結果。當 Done 被 close 的時候，你可以通過 ctx.Err 獲取錯誤信息。Done 這個方法名其實起得並不好，因為名字太過籠統，不能明確反映 Done 被 close 的原因，因為 cancel、timeout、deadline 都可能導致 Done 被 close，不過，目前還沒有一個更合適的方法名稱。</p>
<p>關於 Done 方法，你必須要記住的知識點就是：如果 Done 沒有被 close，Err 方法返回 nil；如果 Done 被 close，Err 方法會返回 Done 被 close 的原因。</p>
<p><strong>Value</strong> 返回此 ctx 中和指定的 key 相關聯的 value。</p>
<p>Context 中實現了 2 個常用的生成頂層 Context 的方法。</p>
<ol>
<li>context.Background()：返回一個非 nil 的、空的 Context，沒有任何值，不會被 cancel，不會超時，沒有截止日期。一般用在主函數、初始化、測試以及創建根 Context 的時候。</li>
<li>context.TODO()：返回一個非 nil 的、空的 Context，沒有任何值，不會被 cancel，不會超時，沒有截止日期。當你不清楚是否該用 Context，或者目前還不知道要傳遞一些什麼上下文信息的時候，就可以使用這個方法。</li>
</ol>
<p>官方文檔是這麼講的，你可能會覺得像沒說一樣，因為界限並不是很明顯。其實，你根本不用費腦子去考慮，可以直接使用 context.Background。事實上，它們兩個底層的實現是一模一樣的：</p>
<pre><code class="language-go">var (
    background = new(emptyCtx)
    todo       = new(emptyCtx)
)

func Background() Context {
    return background
}

func TODO() Context {
    return todo
}
</code></pre>
<p>在使用 Context 的時候，有一些約定俗成的規則。</p>
<ol>
<li>一般函數使用 Context 的時候，會把這個參數放在第一個參數的位置。</li>
<li>從來不把 nil 當做 Context 類型的參數值，可以使用 context.Background() 創建一個空的上下文對象，也不要使用 nil。</li>
<li>Context 只用來臨時做函數之間的上下文透傳，不能持久化 Context 或者把 Context 長久保存。把 Context 持久化到數據庫、本地文件或者全局變量、緩存中都是錯誤的用法。</li>
<li>key 的類型不應該是字符串類型或者其它內建類型，否則容易在包之間使用 Context 時候產生衝突。使用 WithValue 時，key 的類型應該是自己定義的類型。</li>
<li>常常使用 struct{}作為底層類型定義 key 的類型。對於 exported key 的靜態類型，常常是接口或者指針。這樣可以儘量減少內存分配。</li>
</ol>
<p>其實官方的文檔也是比較搞笑的，文檔中強調 key 的類型不要使用 string，結果接下來的例子中就是用 string 類型作為 key 的類型。你自己把握住這個要點就好，如果你能保證別人使用你的 Context 時不會和你定義的 key 衝突，那麼 key 的類型就比較隨意，因為你自己保證了不同包的 key 不會衝突，否則建議你儘量採用保守的 unexported 的類型。</p>
<h1 id="創建特殊用途-context-的方法"><a class="header" href="#創建特殊用途-context-的方法">創建特殊用途 Context 的方法</a></h1>
<p>接下來，我會介紹標準庫中幾種創建特殊用途 Context 的方法：WithValue、WithCancel、WithTimeout 和 WithDeadline，包括它們的功能以及實現方式。</p>
<h2 id="withvalue"><a class="header" href="#withvalue">WithValue</a></h2>
<p>WithValue 基於 parent Context 生成一個新的 Context，保存了一個 key-value 鍵值對。它常常用來傳遞上下文。</p>
<p>WithValue 方法其實是創建了一個類型為 valueCtx 的 Context，它的類型定義如下：</p>
<pre><code class="language-go">type valueCtx struct {
    Context
    key, val interface{}
}
</code></pre>
<p>它持有一個 key-value 鍵值對，還持有 parent 的 Context。它覆蓋了 Value 方法，優先從自己的存儲中檢查這個 key，不存在的話會從 parent 中繼續檢查。</p>
<p>Go 標準庫實現的 Context 還實現了鏈式查找。如果不存在，還會向 parent Context 去查找，如果 parent 還是 valueCtx 的話，還是遵循相同的原則：valueCtx 會嵌入 parent，所以還是會查找 parent 的 Value 方法的。</p>
<pre><code class="language-go">ctx = context.TODO()
ctx = context.WithValue(ctx, "key1", "0001")
ctx = context.WithValue(ctx, "key2", "0001")
ctx = context.WithValue(ctx, "key3", "0001")
ctx = context.WithValue(ctx, "key4", "0004")

fmt.Println(ctx.Value("key1"))
</code></pre>
<p><img src="./images/09fdae9e89bf9c765bb9974d77fc561b.png" alt="" /></p>
<h2 id="withcancel"><a class="header" href="#withcancel">WithCancel</a></h2>
<p>WithCancel 方法返回 parent 的副本，只是副本中的 Done Channel 是新建的對象，它的類型是 cancelCtx。</p>
<p>我們常常在一些需要主動取消長時間的任務時，創建這種類型的 Context，然後把這個 Context 傳給長時間執行任務的 goroutine。當需要中止任務時，我們就可以 cancel 這個 Context，這樣長時間執行任務的 goroutine，就可以通過檢查這個 Context，知道 Context 已經被取消了。</p>
<p>WithCancel 返回值中的第二個值是一個 cancel 函數。其實，這個返回值的名稱（cancel）和類型（Cancel）也非常迷惑人。</p>
<p>記住，不是隻有你想中途放棄，才去調用 cancel，只要你的任務正常完成了，就需要調用 cancel，這樣，這個 Context 才能釋放它的資源（通知它的 children 處理 cancel，從它的 parent 中把自己移除，甚至釋放相關的 goroutine）。很多同學在使用這個方法的時候，都會忘記調用 cancel，切記切記，而且一定儘早釋放。</p>
<p>我們來看下 WithCancel 方法的實現代碼：</p>
<pre><code class="language-go">func WithCancel(parent Context) (ctx Context, cancel CancelFunc) {
    c := newCancelCtx(parent)
    propagateCancel(parent, &amp;c)// 把c朝上傳播
    return &amp;c, func() { c.cancel(true, Canceled) }
}

// newCancelCtx returns an initialized cancelCtx.
func newCancelCtx(parent Context) cancelCtx {
    return cancelCtx{Context: parent}
}
</code></pre>
<p>代碼中調用的 propagateCancel 方法會順著 parent 路徑往上找，直到找到一個 cancelCtx，或者為 nil。如果不為空，就把自己加入到這個 cancelCtx 的 child，以便這個 cancelCtx 被取消的時候通知自己。如果為空，會新起一個 goroutine，由它來監聽 parent 的 Done 是否已關閉。</p>
<p>當這個 cancelCtx 的 cancel 函數被調用的時候，或者 parent 的 Done 被 close 的時候，這個 cancelCtx 的 Done 才會被 close。</p>
<p>cancel 是向下傳遞的，如果一個 WithCancel 生成的 Context 被 cancel 時，如果它的子 Context（也有可能是孫，或者更低，依賴子的類型）也是 cancelCtx 類型的，就會被 cancel，但是不會向上傳遞。parent Context 不會因為子 Context 被 cancel 而 cancel。</p>
<p>cancelCtx 被取消時，它的 Err 字段就是下面這個 Canceled 錯誤：</p>
<pre><code class="language-go">var Canceled = errors.New("context canceled")WithTimeoutWithTimeout 其實是和 WithDeadline 一樣，只不過一個參數是超時時間，一個參數是截止時間。超時時間加上當前時間，其實就是截止時間，因此，WithTimeout 的實現是：

func WithTimeout(parent Context, timeout time.Duration) (Context, CancelFunc) {
    // 當前時間+timeout就是deadline
    return WithDeadline(parent, time.Now().Add(timeout))
}WithDeadlineWithDeadline 會返回一個 parent 的副本，並且設置了一個不晚於參數 d 的截止時間，類型為 timerCtx（或者是 cancelCtx）。
</code></pre>
<p>如果它的截止時間晚於 parent 的截止時間，那麼就以 parent 的截止時間為準，並返回一個類型為 cancelCtx 的 Context，因為 parent 的截止時間到了，就會取消這個 cancelCtx。</p>
<p>如果當前時間已經超過了截止時間，就直接返回一個已經被 cancel 的 timerCtx。否則就會啟動一個定時器，到截止時間取消這個 timerCtx。</p>
<p>綜合起來，timerCtx 的 Done 被 Close 掉，主要是由下面的某個事件觸發的：</p>
<ol>
<li>截止時間到了；</li>
<li>cancel 函數被調用；</li>
<li>parent 的 Done 被 close。</li>
</ol>
<p>下面的代碼是 WithDeadline 方法的實現：</p>
<pre><code class="language-go">func WithDeadline(parent Context, d time.Time) (Context, CancelFunc) {
    // 如果parent的截止時間更早，直接返回一個cancelCtx即可
    if cur, ok := parent.Deadline(); ok &amp;&amp; cur.Before(d) {
        return WithCancel(parent)
    }
    c := &amp;timerCtx{
        cancelCtx: newCancelCtx(parent),
        deadline:  d,
    }
    propagateCancel(parent, c) // 同cancelCtx的處理邏輯
    dur := time.Until(d)
    if dur &lt;= 0 { //當前時間已經超過了截止時間，直接cancel
        c.cancel(true, DeadlineExceeded)
        return c, func() { c.cancel(false, Canceled) }
    }
    c.mu.Lock()
    defer c.mu.Unlock()
    if c.err == nil {
        // 設置一個定時器，到截止時間後取消
        c.timer = time.AfterFunc(dur, func() {
            c.cancel(true, DeadlineExceeded)
        })
    }
    return c, func() { c.cancel(true, Canceled) }
}
</code></pre>
<p>和 cancelCtx 一樣，WithDeadline（WithTimeout）返回的 cancel 一定要調用，並且要儘可能早地被調用，這樣才能儘早釋放資源，不要單純地依賴截止時間被動取消。正確的使用姿勢是啥呢？我們來看一個例子。</p>
<pre><code class="language-go">func slowOperationWithTimeout(ctx context.Context) (Result, error) {
  ctx, cancel := context.WithTimeout(ctx, 100*time.Millisecond)
  defer cancel() // 一旦慢操作完成就立馬調用cancel
  return slowOperation(ctx)
}總結我們經常使用 Context 來取消一個 goroutine 的運行，這是 Context 最常用的場景之一，Context 也被稱為 goroutine 生命週期範圍（goroutine-scoped）的 Context，把 Context 傳遞給 goroutine。但是，goroutine 需要嘗試檢查 Context 的 Done 是否關閉了：

func main() {
    ctx, cancel := context.WithCancel(context.Background())

    go func() {
        defer func() {
            fmt.Println("goroutine exit")
        }()

        for {
            select {
            case &lt;-ctx.Done():
                return
            default:
                time.Sleep(time.Second)
            }
        }
    }()

    time.Sleep(time.Second)
    cancel()
    time.Sleep(2 * time.Second)
}
</code></pre>
<p>如果你要為 Context 實現一個帶超時功能的調用，比如訪問遠程的一個微服務，超時並不意味著你會通知遠程微服務已經取消了這次調用，大概率的實現只是避免客戶端的長時間等待，遠程的服務器依然還執行著你的請求。</p>
<p>所以，有時候，Context 並不會減少對服務器的請求負擔。如果在 Context 被 cancel 的時候，你能關閉和服務器的連接，中斷和數據庫服務器的通訊、停止對本地文件的讀寫，那麼，這樣的超時處理，同時能減少對服務調用的壓力，但是這依賴於你對超時的底層處理機制。</p>
<p><img src="./images/65de1c0df049a32fe8646b222cb06557.png" alt="" /></p>
<h1 id="思考題"><a class="header" href="#思考題">思考題</a></h1>
<p>使用 WithCancel 和 WithValue 寫一個級聯的使用 Context 的例子，驗證一下 parent Context 被 cancel 後，子 conext 是否也立刻被 cancel 了。</p>
<p>歡迎在留言區寫下你的思考和答案，我們一起交流討論。如果你覺得有所收穫，也歡迎你把今天的內容分享給你的朋友或同事。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="11.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="13.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="11.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="13.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
