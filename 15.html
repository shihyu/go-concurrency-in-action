<!DOCTYPE HTML>
<html lang="zh-TW" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>14 | Channel：透過代碼看典型的應用模式 - Go 併發編程實戰課</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
            window.path_to_searchindex_js = "searchindex.js";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="mdbook-help-container">
        <div id="mdbook-help-popup">
            <h2 class="mdbook-help-title">Keyboard shortcuts</h2>
            <div>
                <p>Press <kbd>←</kbd> or <kbd>→</kbd> to navigate between chapters</p>
                <p>Press <kbd>S</kbd> or <kbd>/</kbd> to search in the book</p>
                <p>Press <kbd>?</kbd> to show this help</p>
                <p>Press <kbd>Esc</kbd> to hide this help</p>
            </div>
        </div>
    </div>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
                sidebar_toggle.checked = false;
            }
            if (sidebar === 'visible') {
                sidebar_toggle.checked = true;
            } else {
                html.classList.remove('sidebar-visible');
            }
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search (`/`)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="/ s" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">Go 併發編程實戰課</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <div class="search-wrapper">
                            <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                            <div class="spinner-wrapper">
                                <i class="fa fa-spinner fa-spin"></i>
                            </div>
                        </div>
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="14--channel透過代碼看典型的應用模式"><a class="header" href="#14--channel透過代碼看典型的應用模式">14 | Channel：透過代碼看典型的應用模式</a></h1>
<p>你好，我是鳥窩。</p>
<p>前一講，我介紹了 Channel 的基礎知識，並且總結了幾種應用場景。這一講，我將通過實例的方式，帶你逐個學習 Channel 解決這些問題的方法，幫你鞏固和完全掌握它的用法。</p>
<p>在開始上課之前，我先補充一個知識點：通過反射的方式執行 select 語句，在處理很多的 case clause，尤其是不定長的 case clause 的時候，非常有用。而且，在後面介紹任務編排的實現時，我也會採用這種方法，所以，我先帶你具體學習下 Channel 的反射用法。</p>
<h1 id="使用反射操作-channel"><a class="header" href="#使用反射操作-channel">使用反射操作 Channel</a></h1>
<p>select 語句可以處理 chan 的 send 和 recv，send 和 recv 都可以作為 case clause。如果我們同時處理兩個 chan，就可以寫成下面的樣子：</p>
<pre><code>    select {
    case v := &lt;-ch1:
        fmt.Println(v)
    case v := &lt;-ch2:
        fmt.Println(v)
    }
</code></pre>
<p>如果需要處理三個 chan，你就可以再添加一個 case clause，用它來處理第三個 chan。可是，如果要處理 100 個 chan 呢？一萬個 chan 呢？</p>
<p>或者是，chan 的數量在編譯的時候是不定的，在運行的時候需要處理一個 slice of chan，這個時候，也沒有辦法在編譯前寫成字面意義的 select。那該怎麼辦？</p>
<p>這個時候，就要“祭”出我們的反射大法了。</p>
<p>通過 reflect.Select 函數，你可以將一組運行時的 case clause 傳入，當作參數執行。Go 的 select 是偽隨機的，它可以在執行的 case 中隨機選擇一個 case，並把選擇的這個 case 的索引（chosen）返回，如果沒有可用的 case 返回，會返回一個 bool 類型的返回值，這個返回值用來表示是否有 case 成功被選擇。如果是 recv case，還會返回接收的元素。Select 的方法簽名如下：</p>
<pre><code>func Select(cases []SelectCase) (chosen int, recv Value, recvOK bool)
</code></pre>
<p>下面，我來藉助一個例子，來演示一下，動態處理兩個 chan 的情形。因為這樣的方式可以動態處理 case 數據，所以，你可以傳入幾百幾千幾萬的 chan，這就解決了不能動態處理 n 個 chan 的問題。</p>
<p>首先，createCases 函數分別為每個 chan 生成了 recv case 和 send case，並返回一個 reflect.SelectCase 數組。</p>
<p>然後，通過一個循環 10 次的 for 循環執行 reflect.Select，這個方法會從 cases 中選擇一個 case 執行。第一次肯定是 send case，因為此時 chan 還沒有元素，recv 還不可用。等 chan 中有了數據以後，recv case 就可以被選擇了。這樣，你就可以處理不定數量的 chan 了。</p>
<pre><code>func main() {
    var ch1 = make(chan int, 10)
    var ch2 = make(chan int, 10)

    // 創建SelectCase
    var cases = createCases(ch1, ch2)

    // 執行10次select
    for i := 0; i &lt; 10; i++ {
        chosen, recv, ok := reflect.Select(cases)
        if recv.IsValid() { // recv case
            fmt.Println("recv:", cases[chosen].Dir, recv, ok)
        } else { // send case
            fmt.Println("send:", cases[chosen].Dir, ok)
        }
    }
}

func createCases(chs ...chan int) []reflect.SelectCase {
    var cases []reflect.SelectCase

    // 創建recv case
    for _, ch := range chs {
        cases = append(cases, reflect.SelectCase{
            Dir:  reflect.SelectRecv,
            Chan: reflect.ValueOf(ch),
        })
    }

    // 創建send case
    for i, ch := range chs {
        v := reflect.ValueOf(i)
        cases = append(cases, reflect.SelectCase{
            Dir:  reflect.SelectSend,
            Chan: reflect.ValueOf(ch),
            Send: v,
        })
    }

    return cases
}典型的應用場景瞭解剛剛的反射用法，我們就解決了今天的基礎知識問題，接下來，我就帶你具體學習下 Channel 的應用場景。
</code></pre>
<p>首先來看消息交流。</p>
<h2 id="消息交流"><a class="header" href="#消息交流">消息交流</a></h2>
<p>從 chan 的內部實現看，它是以一個循環隊列的方式存放數據，所以，它有時候也會被當成線程安全的隊列和 buffer 使用。一個 goroutine 可以安全地往 Channel 中塞數據，另外一個 goroutine 可以安全地從 Channel 中讀取數據，goroutine 就可以安全地實現信息交流了。</p>
<p>我們來看幾個例子。</p>
<p>第一個例子是 worker 池的例子。Marcio Castilho 在 使用 Go 每分鐘處理百萬請求 這篇文章中，就介紹了他們應對大併發請求的設計。他們將用戶的請求放在一個 chan Job 中，這個 chan Job 就相當於一個待處理任務隊列。除此之外，還有一個 chan chan Job 隊列，用來存放可以處理任務的 worker 的緩存隊列。</p>
<p>dispatcher 會把待處理任務隊列中的任務放到一個可用的緩存隊列中，worker 會一直處理它的緩存隊列。通過使用 Channel，實現了一個 worker 池的任務處理中心，並且解耦了前端 HTTP 請求處理和後端任務處理的邏輯。</p>
<p>我在講 Pool 的時候，提到了一些第三方實現的 worker 池，它們全部都是通過 Channel 實現的，這是 Channel 的一個常見的應用場景。worker 池的生產者和消費者的消息交流都是通過 Channel 實現的。</p>
<p>第二個例子是 etcd 中的 node 節點的實現，包含大量的 chan 字段，比如 recvc 是消息處理的 chan，待處理的 protobuf 消息都扔到這個 chan 中，node 有一個專門的 run goroutine 處理這些消息。</p>
<p><img src="./images/06932e15be51be922c00e09e10d7fc44.png" alt="" /></p>
<h2 id="數據傳遞"><a class="header" href="#數據傳遞">數據傳遞</a></h2>
<p>“擊鼓傳花”的遊戲很多人都玩過，花從一個人手中傳給另外一個人，就有點類似流水線的操作。這個花就是數據，花在遊戲者之間流轉，這就類似編程中的數據傳遞。</p>
<p>還記得上節課我給你留了一道任務編排的題嗎？其實它就可以用數據傳遞的方式實現。</p>
<blockquote>
<p>有 4 個 goroutine，編號為 1、2、3、4。每秒鐘會有一個 goroutine 打印出它自己的編號，要求你編寫程序，讓輸出的編號總是按照 1、2、3、4、1、2、3、4……這個順序打印出來。</p>
</blockquote>
<p>為了實現順序的數據傳遞，我們可以定義一個令牌的變量，誰得到令牌，誰就可以打印一次自己的編號，同時將令牌<strong>傳遞</strong>給下一個 goroutine，我們嘗試使用 chan 來實現，可以看下下面的代碼。</p>
<pre><code>type Token struct{}

func newWorker(id int, ch chan Token, nextCh chan Token) {
    for {
        token := &lt;-ch         // 取得令牌
        fmt.Println((id + 1)) // id從1開始
        time.Sleep(time.Second)
        nextCh &lt;- token
    }
}
func main() {
    chs := []chan Token{make(chan Token), make(chan Token), make(chan Token), make(chan Token)}

    // 創建4個worker
    for i := 0; i &lt; 4; i++ {
        go newWorker(i, chs[i], chs[(i+1)%4])
    }

    //首先把令牌交給第一個worker
    chs[0] &lt;- struct{}{}
  
    select {}
}
</code></pre>
<p>我來給你具體解釋下這個實現方式。</p>
<p>首先，我們定義一個令牌類型（Token），接著定義一個創建 worker 的方法，這個方法會從它自己的 chan 中讀取令牌。哪個 goroutine 取得了令牌，就可以打印出自己編號，因為需要每秒打印一次數據，所以，我們讓它休眠 1 秒後，再把令牌交給它的下家。</p>
<p>接著，在第 16 行啟動每個 worker 的 goroutine，並在第 20 行將令牌先交給第一個 worker。</p>
<p>如果你運行這個程序，就會在命令行中看到每一秒就會輸出一個編號，而且編號是以 1、2、3、4 這樣的順序輸出的。</p>
<p>這類場景有一個特點，就是當前持有數據的 goroutine 都有一個信箱，信箱使用 chan 實現，goroutine 只需要關注自己的信箱中的數據，處理完畢後，就把結果發送到下一家的信箱中。</p>
<h2 id="信號通知"><a class="header" href="#信號通知">信號通知</a></h2>
<p>chan 類型有這樣一個特點：chan 如果為空，那麼，receiver 接收數據的時候就會阻塞等待，直到 chan 被關閉或者有新的數據到來。利用這個機制，我們可以實現 wait/notify 的設計模式。</p>
<p>傳統的併發原語 Cond 也能實現這個功能，但是，Cond 使用起來比較複雜，容易出錯，而使用 chan 實現 wait/notify 模式就方便很多了。</p>
<p>除了正常的業務處理時的 wait/notify，我們經常碰到的一個場景，就是程序關閉的時候，我們需要在退出之前做一些清理（doCleanup 方法）的動作。這個時候，我們經常要使用 chan。</p>
<p>比如，使用 chan 實現程序的 graceful shutdown，在退出之前執行一些連接關閉、文件 close、緩存落盤等一些動作。</p>
<pre><code>func main() {
  go func() {
      ...... // 執行業務處理
    }()

  // 處理CTRL+C等中斷信號
  termChan := make(chan os.Signal)
  signal.Notify(termChan, syscall.SIGINT, syscall.SIGTERM)
  &lt;-termChan 

  // 執行退出之前的清理動作
    doCleanup()
  
  fmt.Println("優雅退出")
}
</code></pre>
<p>有時候，doCleanup 可能是一個很耗時的操作，比如十幾分鍾才能完成，如果程序退出需要等待這麼長時間，用戶是不能接受的，所以，在實踐中，我們需要設置一個最長的等待時間。只要超過了這個時間，程序就不再等待，可以直接退出。所以，退出的時候分為兩個階段：</p>
<ol>
<li>closing，代表程序退出，但是清理工作還沒做；</li>
<li>closed，代表清理工作已經做完。</li>
</ol>
<p>所以，上面的例子可以改寫如下：</p>
<pre><code>func main() {
    var closing = make(chan struct{})
    var closed = make(chan struct{})

    go func() {
        // 模擬業務處理
        for {
            select {
            case &lt;-closing:
                return
            default:
                // ....... 業務計算
                time.Sleep(100 * time.Millisecond)
            }
        }
    }()

    // 處理CTRL+C等中斷信號
    termChan := make(chan os.Signal)
    signal.Notify(termChan, syscall.SIGINT, syscall.SIGTERM)
    &lt;-termChan

    close(closing)
    // 執行退出之前的清理動作
    go doCleanup(closed)

    select {
    case &lt;-closed:
    case &lt;-time.After(time.Second):
        fmt.Println("清理超時，不等了")
    }
    fmt.Println("優雅退出")
}

func doCleanup(closed chan struct{}) {
    time.Sleep((time.Minute))
    close(closed)
}鎖使用 chan 也可以實現互斥鎖。
</code></pre>
<p>在 chan 的內部實現中，就有一把互斥鎖保護著它的所有字段。從外在表現上，chan 的發送和接收之間也存在著 happens-before 的關係，保證元素放進去之後，receiver 才能讀取到（關於 happends-before 的關係，是指事件發生的先後順序關係，我會在下一講詳細介紹，這裡你只需要知道它是一種描述事件先後順序的方法）。</p>
<p>要想使用 chan 實現互斥鎖，至少有兩種方式。一種方式是先初始化一個 capacity 等於 1 的 Channel，然後再放入一個元素。這個元素就代表鎖，誰取得了這個元素，就相當於獲取了這把鎖。另一種方式是，先初始化一個 capacity 等於 1 的 Channel，它的“空槽”代表鎖，誰能成功地把元素髮送到這個 Channel，誰就獲取了這把鎖。</p>
<p>這是使用 Channel 實現鎖的兩種不同實現方式，我重點介紹下第一種。理解了這種實現方式，第二種方式也就很容易掌握了，我就不多說了。</p>
<pre><code>// 使用chan實現互斥鎖
type Mutex struct {
    ch chan struct{}
}

// 使用鎖需要初始化
func NewMutex() *Mutex {
    mu := &amp;Mutex{make(chan struct{}, 1)}
    mu.ch &lt;- struct{}{}
    return mu
}

// 請求鎖，直到獲取到
func (m *Mutex) Lock() {
    &lt;-m.ch
}

// 解鎖
func (m *Mutex) Unlock() {
    select {
    case m.ch &lt;- struct{}{}:
    default:
        panic("unlock of unlocked mutex")
    }
}

// 嘗試獲取鎖
func (m *Mutex) TryLock() bool {
    select {
    case &lt;-m.ch:
        return true
    default:
    }
    return false
}

// 加入一個超時的設置
func (m *Mutex) LockTimeout(timeout time.Duration) bool {
    timer := time.NewTimer(timeout)
    select {
    case &lt;-m.ch:
        timer.Stop()
        return true
    case &lt;-timer.C:
    }
    return false
}

// 鎖是否已被持有
func (m *Mutex) IsLocked() bool {
    return len(m.ch) == 0
}

func main() {
    m := NewMutex()
    ok := m.TryLock()
    fmt.Printf("locked v %v\n", ok)
    ok = m.TryLock()
    fmt.Printf("locked %v\n", ok)
}
</code></pre>
<p>你可以用 buffer 等於 1 的 chan 實現互斥鎖，在初始化這個鎖的時候往 Channel 中先塞入一個元素，誰把這個元素取走，誰就獲取了這把鎖，把元素放回去，就是釋放了鎖。元素在放回到 chan 之前，不會有 goroutine 能從 chan 中取出元素的，這就保證了互斥性。</p>
<p>在這段代碼中，還有一點需要我們注意下：利用 select+chan 的方式，很容易實現 TryLock、Timeout 的功能。具體來說就是，在 select 語句中，我們可以使用 default 實現 TryLock，使用一個 Timer 來實現 Timeout 的功能。</p>
<h2 id="任務編排"><a class="header" href="#任務編排">任務編排</a></h2>
<p>前面所說的消息交流的場景是一個特殊的任務編排的場景，這個“擊鼓傳花”的模式也被稱為流水線模式。</p>
<p>在第 6 講，我們學習了 WaitGroup，我們可以利用它實現等待模式：啟動一組 goroutine 執行任務，然後等待這些任務都完成。其實，我們也可以使用 chan 實現 WaitGroup 的功能。這個比較簡單，我就不舉例子了，接下來我介紹幾種更復雜的編排模式。</p>
<p>這裡的編排既指安排 goroutine 按照指定的順序執行，也指多個 chan 按照指定的方式組合處理的方式。goroutine 的編排類似“擊鼓傳花”的例子，我們通過編排數據在 chan 之間的流轉，就可以控制 goroutine 的執行。接下來，我來重點介紹下多個 chan 的編排方式，總共 5 種，分別是 Or-Done 模式、扇入模式、扇出模式、Stream 和 Map-Reduce。</p>
<h3 id="or-done-模式"><a class="header" href="#or-done-模式">Or-Done 模式</a></h3>
<p>首先來看 Or-Done 模式。Or-Done 模式是信號通知模式中更寬泛的一種模式。這裡提到了“信號通知模式”，我先來解釋一下。</p>
<p>我們會使用“信號通知”實現某個任務執行完成後的通知機制，在實現時，我們為這個任務定義一個類型為 chan struct{}類型的 done 變量，等任務結束後，我們就可以 close 這個變量，然後，其它 receiver 就會收到這個通知。</p>
<p>這是有一個任務的情況，如果有多個任務，只要有任意一個任務執行完，我們就想獲得這個信號，這就是 Or-Done 模式。</p>
<p>比如，你發送同一個請求到多個微服務節點，只要任意一個微服務節點返回結果，就算成功，這個時候，就可以參考下面的實現：</p>
<pre><code>func or(channels ...&lt;-chan interface{}) &lt;-chan interface{} {
    // 特殊情況，只有零個或者1個chan
    switch len(channels) {
    case 0:
        return nil
    case 1:
        return channels[0]
    }

    orDone := make(chan interface{})
    go func() {
        defer close(orDone)

        switch len(channels) {
        case 2: // 2個也是一種特殊情況
            select {
            case &lt;-channels[0]:
            case &lt;-channels[1]:
            }
        default: //超過兩個，二分法遞歸處理
            m := len(channels) / 2
            select {
            case &lt;-or(channels[:m]...):
            case &lt;-or(channels[m:]...):
            }
        }
    }()

    return orDone
}
</code></pre>
<p>我們可以寫一個測試程序測試它：</p>
<pre><code>func sig(after time.Duration) &lt;-chan interface{} {
    c := make(chan interface{})
    go func() {
        defer close(c)
        time.Sleep(after)
    }()
    return c
}

func main() {
    start := time.Now()

    &lt;-or(
        sig(10*time.Second),
        sig(20*time.Second),
        sig(30*time.Second),
        sig(40*time.Second),
        sig(50*time.Second),
        sig(01*time.Minute),
    )

    fmt.Printf("done after %v", time.Since(start))
}
</code></pre>
<p>這裡的實現使用了一個巧妙的方式，<strong>當 chan 的數量大於 2 時，使用遞歸的方式等待信號</strong>。</p>
<p>在 chan 數量比較多的情況下，遞歸併不是一個很好的解決方式，根據這一講最開始介紹的反射的方法，我們也可以實現 Or-Done 模式：</p>
<pre><code>func or(channels ...&lt;-chan interface{}) &lt;-chan interface{} {
    //特殊情況，只有0個或者1個
    switch len(channels) {
    case 0:
        return nil
    case 1:
        return channels[0]
    }

    orDone := make(chan interface{})
    go func() {
        defer close(orDone)
        // 利用反射構建SelectCase
        var cases []reflect.SelectCase
        for _, c := range channels {
            cases = append(cases, reflect.SelectCase{
                Dir:  reflect.SelectRecv,
                Chan: reflect.ValueOf(c),
            })
        }

        // 隨機選擇一個可用的case
        reflect.Select(cases)
    }()

    return orDone
}
</code></pre>
<p>這是遞歸和反射兩種方法實現 Or-Done 模式的代碼。反射方式避免了深層遞歸的情況，可以處理有大量 chan 的情況。其實最笨的一種方法就是為每一個 Channel 啟動一個 goroutine，不過這會啟動非常多的 goroutine，太多的 goroutine 會影響性能，所以不太常用。你只要知道這種用法就行了，不用重點掌握。</p>
<h3 id="扇入模式"><a class="header" href="#扇入模式">扇入模式</a></h3>
<p>扇入借鑑了數字電路的概念，它定義了單個邏輯門能夠接受的數字信號輸入最大量的術語。一個邏輯門可以有多個輸入，一個輸出。</p>
<p>在軟件工程中，模塊的扇入是指有多少個上級模塊調用它。而對於我們這裡的 Channel 扇入模式來說，就是指有多個源 Channel 輸入、一個目的 Channel 輸出的情況。扇入比就是源 Channel 數量比 1。</p>
<p>每個源 Channel 的元素都會發送給目標 Channel，相當於目標 Channel 的 receiver 只需要監聽目標 Channel，就可以接收所有發送給源 Channel 的數據。</p>
<p>扇入模式也可以使用反射、遞歸，或者是用最笨的每個 goroutine 處理一個 Channel 的方式來實現。</p>
<p>這裡我列舉下遞歸和反射的方式，幫你加深一下對這個技巧的理解。</p>
<p>反射的代碼比較簡短，易於理解，主要就是構造出 SelectCase slice，然後傳遞給 reflect.Select 語句。</p>
<pre><code>func fanInReflect(chans ...&lt;-chan interface{}) &lt;-chan interface{} {
    out := make(chan interface{})
    go func() {
        defer close(out)
        // 構造SelectCase slice
        var cases []reflect.SelectCase
        for _, c := range chans {
            cases = append(cases, reflect.SelectCase{
                Dir:  reflect.SelectRecv,
                Chan: reflect.ValueOf(c),
            })
        }
        
        // 循環，從cases中選擇一個可用的
        for len(cases) &gt; 0 {
            i, v, ok := reflect.Select(cases)
            if !ok { // 此channel已經close
                cases = append(cases[:i], cases[i+1:]...)
                continue
            }
            out &lt;- v.Interface()
        }
    }()
    return out
}
</code></pre>
<p>遞歸模式也是在 Channel 大於 2 時，採用二分法遞歸 merge。</p>
<pre><code>func fanInRec(chans ...&lt;-chan interface{}) &lt;-chan interface{} {
    switch len(chans) {
    case 0:
        c := make(chan interface{})
        close(c)
        return c
    case 1:
        return chans[0]
    case 2:
        return mergeTwo(chans[0], chans[1])
    default:
        m := len(chans) / 2
        return mergeTwo(
            fanInRec(chans[:m]...),
            fanInRec(chans[m:]...))
    }
}
</code></pre>
<p>這裡有一個 mergeTwo 的方法，是將兩個 Channel 合併成一個 Channel，是扇入形式的一種特例（只處理兩個 Channel）。 下面我來藉助一段代碼幫你理解下這個方法。</p>
<pre><code>func mergeTwo(a, b &lt;-chan interface{}) &lt;-chan interface{} {
    c := make(chan interface{})
    go func() {
        defer close(c)
        for a != nil || b != nil { //只要還有可讀的chan
            select {
            case v, ok := &lt;-a:
                if !ok { // a 已關閉，設置為nil
                    a = nil
                    continue
                }
                c &lt;- v
            case v, ok := &lt;-b:
                if !ok { // b 已關閉，設置為nil
                    b = nil
                    continue
                }
                c &lt;- v
            }
        }
    }()
    return c
}扇出模式有扇入模式，就有扇出模式，扇出模式是和扇入模式相反的。
</code></pre>
<p>扇出模式只有一個輸入源 Channel，有多個目標 Channel，扇出比就是 1 比目標 Channel 數的值，經常用在設計模式中的觀察者模式中（觀察者設計模式定義了對象間的一種一對多的組合關係。這樣一來，一個對象的狀態發生變化時，所有依賴於它的對象都會得到通知並自動刷新）。在觀察者模式中，數據變動後，多個觀察者都會收到這個變更信號。</p>
<p>下面是一個扇出模式的實現。從源 Channel 取出一個數據後，依次發送給目標 Channel。在發送給目標 Channel 的時候，可以同步發送，也可以異步發送：</p>
<pre><code>func fanOut(ch &lt;-chan interface{}, out []chan interface{}, async bool) {
    go func() {
        defer func() { //退出時關閉所有的輸出chan
            for i := 0; i &lt; len(out); i++ {
                close(out[i])
            }
        }()

        for v := range ch { // 從輸入chan中讀取數據
            v := v
            for i := 0; i &lt; len(out); i++ {
                i := i
                if async { //異步
                    go func() {
                        out[i] &lt;- v // 放入到輸出chan中,異步方式
                    }()
                } else {
                    out[i] &lt;- v // 放入到輸出chan中，同步方式
                }
            }
        }
    }()
}
</code></pre>
<p>你也可以嘗試使用反射的方式來實現，我就不列相關代碼了，希望你課後可以自己思考下。</p>
<h3 id="stream"><a class="header" href="#stream">Stream</a></h3>
<p>這裡我來介紹一種把 Channel 當作流式管道使用的方式，也就是把 Channel 看作流（Stream），提供跳過幾個元素，或者是隻取其中的幾個元素等方法。</p>
<p>首先，我們提供創建流的方法。這個方法把一個數據 slice 轉換成流：</p>
<pre><code>func asStream(done &lt;-chan struct{}, values ...interface{}) &lt;-chan interface{} {
    s := make(chan interface{}) //創建一個unbuffered的channel
    go func() { // 啟動一個goroutine，往s中塞數據
        defer close(s) // 退出時關閉chan
        for _, v := range values { // 遍歷數組
            select {
            case &lt;-done:
                return
            case s &lt;- v: // 將數組元素塞入到chan中
            }
        }
    }()
    return s
}
</code></pre>
<p>流創建好以後，該咋處理呢？下面我再給你介紹下實現流的方法。</p>
<ol>
<li>takeN：只取流中的前 n 個數據；</li>
<li>takeFn：篩選流中的數據，只保留滿足條件的數據；</li>
<li>takeWhile：只取前面滿足條件的數據，一旦不滿足條件，就不再取；</li>
<li>skipN：跳過流中前幾個數據；</li>
<li>skipFn：跳過滿足條件的數據；</li>
<li>skipWhile：跳過前面滿足條件的數據，一旦不滿足條件，當前這個元素和以後的元素都會輸出給 Channel 的 receiver。</li>
</ol>
<p>這些方法的實現很類似，我們以 takeN 為例來具體解釋一下。</p>
<pre><code>func takeN(done &lt;-chan struct{}, valueStream &lt;-chan interface{}, num int) &lt;-chan interface{} {
    takeStream := make(chan interface{}) // 創建輸出流
    go func() {
        defer close(takeStream)
        for i := 0; i &lt; num; i++ { // 只讀取前num個元素
            select {
            case &lt;-done:
                return
            case takeStream &lt;- &lt;-valueStream: //從輸入流中讀取元素
            }
        }
    }()
    return takeStream
}Map-Reducemap-reduce 是一種處理數據的方式，最早是由 Google 公司研究提出的一種面向大規模數據處理的並行計算模型和方法，開源的版本是 hadoop，前幾年比較火。
</code></pre>
<p>不過，我要講的並不是分佈式的 map-reduce，而是單機單進程的 map-reduce 方法。</p>
<p>map-reduce 分為兩個步驟，第一步是映射（map），處理隊列中的數據，第二步是規約（reduce），把列表中的每一個元素按照一定的處理方式處理成結果，放入到結果隊列中。</p>
<p>就像做漢堡一樣，map 就是單獨處理每一種食材，reduce 就是從每一份食材中取一部分，做成一個漢堡。</p>
<p>我們先來看下 map 函數的處理邏輯:</p>
<pre><code>func mapChan(in &lt;-chan interface{}, fn func(interface{}) interface{}) &lt;-chan interface{} {
    out := make(chan interface{}) //創建一個輸出chan
    if in == nil { // 異常檢查
        close(out)
        return out
    }

    go func() { // 啟動一個goroutine,實現map的主要邏輯
        defer close(out)
        for v := range in { // 從輸入chan讀取數據，執行業務操作，也就是map操作
            out &lt;- fn(v)
        }
    }()

    return out
}
</code></pre>
<p>reduce 函數的處理邏輯如下：</p>
<pre><code>func reduce(in &lt;-chan interface{}, fn func(r, v interface{}) interface{}) interface{} {
    if in == nil { // 異常檢查
        return nil
    }

    out := &lt;-in // 先讀取第一個元素
    for v := range in { // 實現reduce的主要邏輯
        out = fn(out, v)
    }

    return out
}
</code></pre>
<p>我們可以寫一個程序，這個程序使用 map-reduce 模式處理一組整數，map 函數就是為每個整數乘以 10，reduce 函數就是把 map 處理的結果累加起來：</p>
<pre><code>// 生成一個數據流
func asStream(done &lt;-chan struct{}) &lt;-chan interface{} {
    s := make(chan interface{})
    values := []int{1, 2, 3, 4, 5}
    go func() {
        defer close(s)
        for _, v := range values { // 從數組生成
            select {
            case &lt;-done:
                return
            case s &lt;- v:
            }
        }
    }()
    return s
}

func main() {
    in := asStream(nil)

    // map操作: 乘以10
    mapFn := func(v interface{}) interface{} {
        return v.(int) * 10
    }

    // reduce操作: 對map的結果進行累加
    reduceFn := func(r, v interface{}) interface{} {
        return r.(int) + v.(int)
    }

    sum := reduce(mapChan(in, mapFn), reduceFn) //返回累加結果
    fmt.Println(sum)
}總結這節課，我藉助代碼示例，帶你學習了 Channel 的應用場景和應用模式。這幾種模式不是我們學習的終點，而是學習的起點。掌握了這幾種模式之後，我們可以延伸出更多的模式。
</code></pre>
<p>雖然 Channel 最初是基於 CSP 設計的用於 goroutine 之間的消息傳遞的一種數據類型，但是，除了消息傳遞這個功能之外，大家居然還演化出了各式各樣的應用模式。我不確定 Go 的創始人在設計這個類型的時候，有沒有想到這一點，但是，我確實被各位大牛利用 Channel 的各種點子折服了，比如有人實現了一個基於 TCP 網絡的分佈式的 Channel。</p>
<p>在使用 Go 開發程序的時候，你也不妨多考慮考慮是否能夠使用 chan 類型，看看你是不是也能創造出別具一格的應用模式。</p>
<p><img src="./images/f1bf2e33add2f016d0ba6ae84c31e859.png" alt="" /></p>
<h1 id="思考題"><a class="header" href="#思考題">思考題</a></h1>
<p>想一想，我們在利用 chan 實現互斥鎖的時候，如果 buffer 設置的不是 1，而是一個更大的值，會出現什麼狀況嗎？能解決什麼問題嗎？</p>
<p>歡迎在留言區寫下你的思考和答案，我們一起交流討論。如果你覺得有所收穫，也歡迎你把今天的內容分享給你的朋友或同事。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="14.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="16.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="14.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="16.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->



    </div>
    </body>
</html>
